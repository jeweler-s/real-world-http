# HTTP/2의 Syntax와 Semantics

> 2 이후에는 뭐가 달라졌을까요?
> 

### 🎨 데이터 표현

*프로토콜을 직접 읽고 쓰는 클라이언트 코드나 서버 관점에서는 큰 변경이 있더라~*

- **(파이프라인 →)스트림을 사용해 (텍스트 →)바이너리 데이터를 다중 송수신**하는 구조로 변경
- 스트림 내 우선 순위 설정
- 서버 사이드에서 데이터 통신을 하는 서버 사이드 푸시 구현
- 헤더 압축

### 🤙🏻 프로토콜

*HTTP/2의 목적은 통신 고속화 !*

- **캐시(max-age)**: 통신 자체를 취소
- **캐시(ETag, Date)**: 변경이 없으면 바디 전송 취소
- **Keep-Alive**: 액세스마다 연결에 걸리는 시간을 줄임
- **압축**: 응답 바디 크기 절감
- **청크**: 응답 전송 시작을 빠르게 함
- **파이프라이닝**: 통신 다중화
    - 하위 호환성 문제가 일어나기 어려움. 통째로 통신 방식 전환

### 🌊 스트림

**AS-IS (~ HTTP/1.1)**

- 텍스트 기반 
    - → 헤더의 끝을 찾으려면 1바이트 씩 미리 읽어야함 (순차적, **병렬 어려움**)
- 하나의 요청이 TCP 소켓 독점
- 청크 형식이라고 해도 하나의 요청 중에 다른 요청을 처리할 수 없음

**TO-BE**

- 바이너리 기반
    - 처음에 프레임 크기가 들어가서 데이터를 프레임 단위로 쉽게 분리 가능 (고속 요청 가능)
- 프레임 단위 송수신
- 하나의 TCP 전송 안에 **스트림**`(가상의 TCP 소켓)`을 만들어 통신
    - 프레임에 따른 플래그로 간단히 열고 닫을 수 있음
    - 핸드셰이크가 불필요함
    - 쉽게 많은 양의 접속을 병렬화할 수 있음
- 청크가 프레임으로 분할되어 있고 프레임끼리 독립적임

### 🕹️ 플로 컨트롤

*애플리케이션 계층이지만 전송 계층과도 가깝습니다 …?*

- TCP 소켓 - HTTP/2 스트림의 관계는 OS 스레드 - 그린 스레드와 비슷하다.
- **스트림을 효율적으로 흐르게 하기 위해 통신량 제어** 처리를 하는 기법

### 🚄 서버 푸시

- 우선순위가 높은 컨텐츠를 **클라이언트가 요구하기 전**에 전송
    - 정적 파일을 다운로드하는 용도
    - 푸시된 컨텐츠는 사전에 `캐시`에 들어감 → 클라이언트 요청 시 바로 다운로드 되는 것처럼 보임
    - 클라이언트의 푸시 감지는 불가함

### 🔩 웹소켓

*서버-클라이언트 간 오버헤드가 적은 양방향 통신*

- HTTP 기본 요소 중 바디만 보내는 것과 같음 (전송할 곳에 관한 정보를 갖지 않음)
- **Stateful** 통신
- 요청할 때마다 다른 서버가 응답해도 전송한 ID를 일원적으로 관리해서 보증할 수 있다면 이상 없음
- 쉽게 쓰고 호환성을 높이기 위해 Socket.IO라는 라이브러리를 경유해서 쓸 수 있다고도 한다…
    - ~~웹소켓을 지원하지 않는 브라우저가 거의 없다는데, 굳이 외부 라이브러리를 써야할까?~~

### 🪄 AMP

*특히 휴대 기기에서 웹페이지의 로딩 속도를 빠르게 하는 방법*

- 필요한 정보가 설정된 페이지라면, 캐러셀 형식으로 요약과 함께 목록이 표시됨
- `JSON-LD` 태그를 통해 검색 순위가 높아진 것 같은 효과를 낼 수 있음 !
- 검색 엔진 스파이더가 AMP 컨텐츠를 발견하면 모든 내용을 구글의 CDN에 복사함

**고속화 기법**

- 페이지 구성 고정화 → 페이지 로딩 고속화, CDN 지원 쉬움
- 컨텐츠를 CDN에 업로드 → 자바스크립트 파일을 캐시에 올리기 쉬움

### 📹 HLS

*HTTP 라이브 스트리밍*

**장점**

- 특수 프로토콜이 아닌 **HTTP를 사용**하여 전 세계 라우터가 지원할 수 있다.
    - 웹 서버와 동일한 서버를 사용하거나, CDN을 사용할 수 있음
- MIME 타입, 캐시 유효 기간만 서버 측에서 설정해주면 된다.

**단점**

- 스트리밍이라고 자칭하지만, 실제로는 점진적 다운로드 방식이다.
    - 청크별로 다운로드가 끝나지 않으면 재생이 시작되지 않아 지연이 발생한다.
- 지원되지 않는 환경이 많다.
