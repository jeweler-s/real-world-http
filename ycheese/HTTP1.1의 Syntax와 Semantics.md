# HTTP/1.1의 Syntax와 Semantics

> 1.1 이후에 추가된 기능에 대해 맛봅시다.
> 

### Keep-Alive

- TCP/IP 통신을 효율화하는 구조
    - 연속된 요청에 접속을 다시 이용함으로써 접속까지의 대기 시간이 줄고 통신 처리량이 많아짐
    - 핸드셰이크 횟수를 줄임

**언제 접속이 끊기는가?**

- 클라이언트, 서버 둘 다 타임아웃을 가짐 → 둘 중 짧은 쪽이 사용됨

### 파이프라이닝

- 최초의 요청이 완료되기 전에 다음 요청을 보내는 기술
- 대기 시간을 없애서 네트워크 가동률을 높이고 성능을 향상시킴
- Keep-Alive 이용 필수
- 서버는 요청이 들어온 순서대로 응답 반환

**HOL 블로킹**

응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 준다.

실제로 파이프라이닝을 사용했을 때 성능이 거의 좋아지지 않을수도

🤭 HTTP/2에서 스트림이라는 구조로 다시 태어나 여러 문제가 해결되었다고 하네요 Coming Soon

### TLS

- 통신 경로를 암호화하는 규격화된 전송 계층 보안
- 기존 프로토콜 + 통신 경로의 안전성
- HTTP 통신을 중계하는 게이트웨이 입장) 암호화되어 통신 내용을 엿보거나 변경할 수 없는 양방향 통신
- SSL이라고 불리던 시절도 있었지만, 실제 SSL은 여러가지 취약성이 알려져 있음. 실제로 사용되는 것은 대부분 TLS이다.

**HTTPS는 뭐가 좋아서 쓰나요?**

- ⭐️ 통신 내용을 암호화하여 HTTP의 약점을 보완한다.
    - 평문 통신이기 때문에 **도청**이 가능
    - 통신 상대를 확인하지 않아 **위장**이 가능
    - 완전성 증명이 불가하여 **변조**가 가능

**보안 과정**

- 통신마다 한 번만 사용되는 공통 키를 만들어내고
- 공개 키 방식을 사용해 통신 상대에게 키를 전달한 후
- 공통 키로 고속으로 암호화하는 2단계 방식을 사용

**통신 절차**

> 1) 핸드셰이크 프로토콜로 통신을 확립 2) 통신 3) SessionTicket을 이용한 재접속 시 고속 핸드셰이크
> 
1. `(클라이언트 → 서버)` SSL 서버 인증서 취득
2. `(클라이언트 → 인증기관)` 서버 인증서의 신뢰성 확인
3. `(클라이언트)` 공통 키를 작성해 인증서 내 공개 키로 암호화
4. `(서버)` 암호화된 키의 복호
5. `(클라이언트 ↔ 서버)` 복호화된 키로 통신

### 메서드 추가

**PUT과 DELETE**

[XMLHttpRequest](https://www.notion.so/HTTP-1-1-Syntax-Semantics-1a5e79eb353c44909b6ca88db34e793c?pvs=21)를 사용해야 한다.

**❌ OPTIONS**

- 서버가 받아들일 수 있는 메서드 목록 반환
- Response Header(Allow)에 결과가 들어있다.

**❌ TRACE**

- 클라이언트가 보낸 요청 메시지가 서버를 통해 다시 돌아오는 것을 허용하는 데 사용

**CONNECT**

- 프록시 서버를 거쳐 대상 서버에 접속하는 것을 목적으로 함 (https 통신 중계 용도)

### 청크

- 전체를 작게 나눠 전송하는 데이터 표현 방식
- 오래 걸리는 데이터 전송을 조금씩 앞당겨 시행 가능 (스트리밍 업로드/다운로드)
- curl로 청크 형식 업로드를 하기 위해 파일 전송(-T)과 함께 헤더 지정 (8KB씩 나누어 전송)

### 파일 다운로드

> 다운로드해주셔서 감사합니다.
만약 다운로드가 시작되지 않을 때는 *이곳*을 클릭하세요.
> 

서버는 2개의 URL을 제공한다.

- 실제 파일을 다운로드하는 페이지
    - `Content-Disposition` 헤더로 다운로드할 파일을 Body로 반환
- HTML 페이지
    - `<meta http-equiv=”refresh” content=”0;URL=./download_file”>`헤더 포함

브라우저가 페이지를 표시할 때 `Content-Disposition` 헤더가 있으면 **다운로드만** 진행

### XMLHttpRequest

**브라우저의 HTTP 요청과의 차이**

- 송수신할 때 HTML 화면이 새로고침되지 않음
- GET/POST 외의 메서드도 전송 가능
- 다양한 데이터 형식(text, JSON, binary data, XML, …)을 송수신할 수 있음

**보안**

- 악의적인 스크립트가 포함되면 예상치 못한 데이터 변조나 탈취가 일어날 수 있음
- 엑세스할 수 있는 정보 제한) 쿠키
- 전송 제한) 도메인, 메서드, 헤더 (CORS)

### 코멧

- XMLHttpRequest를 이용한 실시간 양방향 통신 기술
- 단방향 통신을 이용해 양방향 통신을 함 (레거시 구조 응용)
    - 폴링: 받는 쪽에서 데이터가 있는지 직접 물음
    - 롱 폴링: 접속 완료 권한이 서버에 있는 점을 응용해 서버 응답을 적절한 타이밍에 돌려줌
- 메시지 당 오버헤드가 큰 편

### 지오로케이션

**클라이언트가 자신의 물리적 위치를 구하는 방법**

- 모던 브라우저가 제공하는 지오로케이션 API 활용

**서버가 클라이언트 위치를 추측하는 방법**

- GeoIP라고 불리는 IP 주소로 추측

### SSO

한 번의 로그인을 전 시스템에 유효하게 하는 기술

- 각 서비스 앞단에 HTTP 프록시 서버를 두고 인증을 대행
- 각 서비스에 인증을 대행하는 에이전트를 넣고 로그인 시 중앙 서버에 액세스해 로그인 여부 확인

**관련 키워드**

- 커베로스 인증
- SAML

### OAuth

권한 부여에 특화된 시스템, 클라이언트가 외부 웹 서비스에 무엇을 허가할지 직접 결정

**OAuth 2.0**

- Authorization Code
    - 웹 서비스의 서버 내 client_secret을 감출 수 있고 외부에서 볼 가능성이 없는 경우 사용
- Implicit Grant
    - client_secret 없이 액세스할 수 있는 패턴. 클라이언트의 신원 보증 X
- Resource Owner Password Credentials Grant
    - 허가 서버가 신뢰하는 클라이언트에서 사용
- Client Credentials Grant
    - 사용자 동의 없이 client_secret을 이용한 클라이언트 인증만 진행
    - 서버 사이드 등 client_secret을 외부로부터 감출 수 있는 환경에서 이용 가능

**OpenID Connect**

- OAuth 2.0을 기반으로 한 권한 부여 + 인증 확장 규격 (사실상 표준)
- 사용자 프로필에 액세스하는 방법을 규격화함
